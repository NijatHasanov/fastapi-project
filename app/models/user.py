from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, selectfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import relationshipfrom sqlalchemy.ext.asyncio import AsyncSessionfrom pydantic import BaseModel, EmailStrfrom datetime import datetime, timedeltafrom passlib.context import CryptContextfrom fastapi import HTTPException, status, Dependsfrom fastapi.security import OAuth2PasswordBearerimport jwtfrom jwt import JWTErrorfrom typing import Optionalimport re# Settings configurationclass Settings:    JWT_SECRET = "your-secret-key-here-change-this-in-production"    ALGORITHM = "HS256"settings = Settings()Base = declarative_base()pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")# Pydantic modelsclass UserBase(BaseModel):    username: str    email: Optional[EmailStr] = None    role: str = "viewer"class UserCreate(UserBase):    password: strclass UserUpdate(BaseModel):    email: Optional[EmailStr] = None    password: Optional[str] = None    role: Optional[str] = Noneclass UserResponse(UserBase):    id: int    created_at: datetime    last_login: Optional[datetime] = None    class Config:        from_attributes = Trueclass Token(BaseModel):    access_token: str    refresh_token: str    token_type: strclass TokenData(BaseModel):    username: Optional[str] = None    role: Optional[str] = None    token_type: Optional[str] = None# SQLAlchemy modelsclass User(Base):    __tablename__ = "users"    id = Column(Integer, primary_key=True)    username = Column(String, unique=True, index=True)    email = Column(String, unique=True, index=True, nullable=True)    password_hash = Column(String)    role = Column(String)  # "admin" or "viewer"    created_at = Column(DateTime, default=datetime.utcnow)    last_login = Column(DateTime, nullable=True)    def set_password(self, password: str):        """Set user password with hashing"""        if not validate_password(password):            raise ValueError("Password does not meet complexity requirements")        self.password_hash = hash_password(password)    def check_password(self, password: str) -> bool:        """Check if provided password matches user's password"""        return verify_password(password, self.password_hash)class RefreshToken(Base):    __tablename__ = "refresh_tokens"    id = Column(Integer, primary_key=True)    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"))    token = Column(String, unique=True, index=True)    expires_at = Column(DateTime)    revoked = Column(Boolean, default=False)    created_at = Column(DateTime, default=datetime.utcnow)# Password complexity settingsPASSWORD_MIN_LENGTH = 8PASSWORD_PATTERNS = [    (r"[A-Z]", "uppercase letter"),    (r"[a-z]", "lowercase letter"),    (r"\d", "number"),    (r"[!@#$%^&*(),.?\":{}|<>]", "special character")]# Token settingsACCESS_TOKEN_EXPIRE_MINUTES = 30REFRESH_TOKEN_EXPIRE_DAYS = 7# Password functionsdef verify_password(plain_password: str, hashed_password: str) -> bool:    return pwd_context.verify(plain_password, hashed_password)def hash_password(password: str) -> str:    return pwd_context.hash(password)def validate_password(password: str) -> bool:    """Validate password meets complexity requirements"""    if len(password) < PASSWORD_MIN_LENGTH:        return False        for pattern, description in PASSWORD_PATTERNS:        if not re.search(pattern, password):            return False        return True# Database functionsasync def get_user_by_username(username: str, db: AsyncSession) -> Optional[User]:    result = await db.execute(select(User).filter(User.username == username))    return result.scalar_one_or_none()async def get_user_by_id(user_id: int, db: AsyncSession) -> Optional[User]:    result = await db.execute(select(User).filter(User.id == user_id))    return result.scalar_one_or_none()async def authenticate_user(username: str, password: str, db: AsyncSession) -> Optional[User]:    user = await get_user_by_username(username, db)    if not user:        return None    if not verify_password(password, user.password_hash):        return None    # Update last login time    user.last_login = datetime.utcnow()    await db.commit()    return user# JWT token functionsdef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):    to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({"exp": expire})    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET, algorithm=settings.ALGORITHM)    return encoded_jwtdef create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None):    to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)    to_encode.update({"exp": expire, "type": "refresh"})    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET, algorithm=settings.ALGORITHM)    return encoded_jwt# FastAPI dependenciesasync def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends()) -> User:    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail="Could not validate credentials",        headers={"WWW-Authenticate": "Bearer"},    )    try:        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.ALGORITHM])        username: str = payload.get("sub")        role: str = payload.get("role")        if username is None:            raise credentials_exception        token_data = TokenData(username=username, role=role)    except JWTError:        raise credentials_exception        user = await get_user_by_username(token_data.username, db)    if user is None:        raise credentials_exception    return userasync def get_current_admin(current_user: User = Depends(get_current_user)) -> User:    if current_user.role != "admin":        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Not enough permissions"        )    return current_userasync def get_current_user_optional(token: Optional[str] = Depends(oauth2_scheme)) -> Optional[User]:    """Get current user if token is provided, otherwise return None"""    if not token:        return None
    try:
        # You would need to inject db here too in a real implementation
        # This is a simplified version
        return None  # Replace with actual implementation
    except:
        return None
